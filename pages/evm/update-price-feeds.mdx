import Input from "../../components/Input";
import Arg from "../../components/Arg";
import { InputFormats } from "../../utils/InputFormat";
import Example from "../../components/Example";
import DynamicCode from "../../components/DynamicCode";
import EvmSend from "../../components/EvmSend";
import { Tab, Tabs } from "nextra-theme-docs";

# Update Price Feeds

**updatePriceFeeds(updateData: bytes[])**

Update the on-chain price feeds using the provided data payloads.
You can retrieve these data payloads using the Price Service API.

| Argument                                           |                                                       | Description                                                              |
| -------------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------------------------ |
| <Arg required={true} type="hex[]">updateData</Arg> | <Input id="updateData" format={InputFormats.ZeroX} /> | The price update data for the contract to verify.                        |
| <Arg required={true} type="wei">fee</Arg>          | <Input id="fee" format={InputFormats.BigInt}/>        | The update fee in wei. This fee is sent as the value of the transaction. |

<Example
  keyValues={{
    updateData: (ctx) => ctx.getLatestVaa("Crypto.BTC/USD"),
    fee: (ctx) => {
      // NOTE: this technically could get the update fee for a different VAA than the one above.
      // This shouldn't affect the update fee as long as the fee is only dependent on the price feed ids
      // and not the specific content of the price update.
      let vaa = ctx.getLatestVaa("Crypto.BTC/USD");
      return ctx.getUpdateFee([vaa]);
    },
  }}
>
  Latest BTC/USD update data
</Example>

<EvmSend
  functionName="updatePriceFeeds"
  buildArguments={(kvs) => [[kvs["updateData"]]]}
  feeKey="fee"
/>

## Example Code

<Tabs items={['Solidity', 'ethers.js v6']}>
  <Tab>

      <DynamicCode targets={{
          "0x0000000000000000000000000000000000000000": (ctx) => ctx.evmConfig.pythAddress,
          "\"11\"": (ctx) => `"${ctx.get("updateData", "<updateData>").replace("0x", "")}"`,
          "2": (ctx) => ctx.get("fee", "<fee>"),
      }}>
          ```solidity
          import "pyth-sdk-solidity/IPyth.sol";
          import "pyth-sdk-solidity/PythStructs.sol";

          address contractAddress = 0x0000000000000000000000000000000000000000;
          IPyth pyth = IPyth(contractAddress);

          bytes[] memory updateData = new bytes[](1);
          updateData[0] = hex"11";

          uint fee = 2;
          pyth.updatePriceFeeds{value: fee}(updateData);
          ```
      </DynamicCode>

  </Tab>

  <Tab>
      <DynamicCode targets={{
          "'0x0000'": (ctx) => `'${ctx.evmConfig.pythAddress}'`,
          "'0x1111'": (ctx) => `'${ctx.get("updateData", "<updateData>")}'`,
          "2": (ctx) => ctx.get("fee", "<fee>")
      }}>
          ```typescript
          import { ethers } from "ethers";
          import PythAbi from "@pythnetwork/pyth-sdk-solidity/abis/IPyth.json" assert { type: "json" };

          const contractAddress = '0x0000';
          const provider = ethers.getDefaultProvider("YOUR_RPC_URL");
          const contract = new ethers.Contract(contractAddress, PythAbi, provider);

          const fee = ethers.toBigInt(2)

          const updateData = ['0x1111'];
          const tx = await contract.updatePriceFeeds(updateData, {value: fee});
          const receipt = await tx.wait();
          ```
      </DynamicCode>

  </Tab>
</Tabs>
