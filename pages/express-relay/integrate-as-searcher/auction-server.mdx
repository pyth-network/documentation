# Integrate with auction server

## Submitting bids

Searchers submit their bids on transactions they wish to execute to the off-chain auction server of the Express Relay. The auction server lives at (TODO: INSERT ENDPOINT), and its API documentation can be found here (TODO: INSERT SWAGGER DOCS). You can use the express relay [JavaScript SDK](https://www.npmjs.com/package/@pythnetwork/express-relay-evm-js) or [Python SDK](https://pypi.org/project/express-relay/) for a more native integration.

To submit a bid to the auction server, a searcher can use either websocket (if they wish to subscribe to updates on the status of their bid) or the HTTP `/v1/bids` POST method. 

### HTTP

The HTTP POST request should be submitted with a JSON request body representing the searcher's `Bid` object. An example is provided below:

```
{
    "chain_id": "op_sepolia",
    "permission_key": "0x00000000000000000000000087ee27c5ae396b28a825968b277fece0720f5907000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000",
    "target_contract": "0x87ee27c5ae396b28a825968b277fece0720f5907"
    "target_calldata": "0xeadb38050000000000000000000000000000000000000000000000000000000000000064",
    "amount": "10",
}
```

The fields of this object are described in more detail below:
- `chain_id`: The `string` identifying the chain on which the searcher wishes to submit the transaction.
- `permission_key`: The `bytes` (in the form of a 0x-prefixed hex string) that serve as the unique identifying information for a position within a protocol
- `target_contract`: The `address` of the contract the searcher wishes to call from the `ExpressRelay` contract. This could be the searcher's own contract or the [`OpportunityAdapterFactory` contract](./integrate-as-searcher/opportunity-adapter).
- `target_calldata`: The `bytes` (in the form of a 0x-prefixed hex string) of the calldata the searcher wishes to call the `targetContract` with.
- `amount`: The amount of ETH (in wei) the searcher is bidding for their transaction's priority. 

### WebSocket

The WebSocket version of the above bid is very similar:

```
{
	"id": "1",
	"method": "post_bid",
	"params": {
		"bid": {
            "chain_id": "op_sepolia",
            "permission_key": "0x00000000000000000000000087ee27c5ae396b28a825968b277fece0720f5907000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000",
            "target_contract": "0x87ee27c5ae396b28a825968b277fece0720f5907"
            "target_calldata": "0xeadb38050000000000000000000000000000000000000000000000000000000000000064",
		    "amount": "10",
		}
	}
}
```

A successful response to bid submission has the following schema:

```
{
	"id": "1", // websocket request id
	"status": "success"
    "result": {
        "id": "beedbeed-b346-4fa1-8fab-2541a9e1872d", // bid id
        "status": "OK"
    }
}
```

From this point on, you will receive notifications about the bid status updates in JSON format. There are four types of bid status updates ("pending", "submitted", "lost", "won"), and you can find more details and examples in the `BidStatus` schema in the Schemas section of the API documentation (TODO: INSERT SWAGGER DOCS).

#### WebSocket connection persistence

The WebSocket server responds to ping messages according to WebSocket standards. Additionally, the server periodically sends a ping message to the client to ensure the connection is still active and expects a pong in return.

## Discovering transactions to bid on

In addition, the server has a set of opportunity endpoints that expose [opportunities](./how-express-relay-works/opportunities) as they become available. An `Opportunity` has the following structure:

```
{
    "chain_id": "op_sepolia",
    "permission_key": "0x00000000000000000000000087ee27c5ae396b28a825968b277fece0720f5907000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000",
    "target_contract": "0x87ee27c5ae396b28a825968b277fece0720f5907",
    "target_calldata": "0xdeadbeef",
    "target_call_value": "1",
    "buy_tokens": [
        {
            "amount": "3",
            "contract": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
        }
    ],
    "sell_tokens": [
        {
            "amount": "1",
            "contract": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599"
        }
    ],
    "version": "v1"
}
```

The fields of the `Opportunity` are described below:
- `chain_id`: The chain id where the opportunity is available
- `permission_key`: The permission key corresponding to the opportunity
- `target_contract`: The protocol contract address where the opportunity is available
- `target_calldata`: The calldata to be used to execute the opportunity
- `target_call_value`: The value to be sent to the `target_contract` in wei
- `buy_tokens`: The tokens to be received as a result of the execution of the opportunity
- `sell_tokens`: The tokens to be spent when executing the opportunity

Note that the `target_contract` and `target_calldata` fields of an `Opportunity` are not intended to be used for the fields in a `Bid`. Rather, this `target_contract` and `target_calldata` represent parameters for the call to the [`OpportunityAdapter` contract](./integrate-as-searcher/opportunity-adapter).

To query current opportunities, searchers can either make a HTTP `/v1/opportunities` GET request or subscribe to WebSocket updates on opportunities. To subscribe via WebSocket, you can send a request with the chain_ids parameter which specifies the chains as an array:

```
{
	"id": "1",
	"method": "subscribe",
	"params": {
		"chain_ids": ["op_sepolia"]
	}
}
```

After a successful subscription you will receive the new opportunities for the selected chains via the websocket in the following format:

```
{
	"type": "new_opportunity",
	"opportunity": {...}
}
```

with the opportunity being presented in a schema similar to above.

In order to unsubscribe from a list of chains, you can send the following message:

```
{
	"id": "1",
	"method": "unsubscribe",
	"params": {
		"chain_ids": ["op_sepolia"]
	}
}
```

For most searchers, it is recommended to source opportunities via the opportunity endpoints and construct transactions intended for the [`OpportunityAdapter`](./integrate-as-searcher/opportunity-adapter). The SDKs expose methods to craft the calldata for the `OpportunityAdapter` contract and construct and submit the `Bid`.

If you prefer to use your own custom contracts rather than the `OpportunityAdpater` contract for executing opportunities, you can still use the server's opportunity endpoints to learn about opportunities on specific protocols and then craft a `Bid` based on an `Opportunity`. Here is a simplified example of a custom contract method that uses the `Opportunity` information to call a liquidation.

```solidity
...
function callLiquidation(Opportunity memory opp){
    for (uint i=0; i<opp.sell_tokens.length; i++) {
        let token = opp.sell_tokens[i];
        IERC20(token.contract).approve(opp.contract, token.amount);
    }

    uint256[] before = new uint256[](opp.buy_tokens.length);
    for (uint j=0; j<opp.buy_tokens.length; j++) {
        let token = opp.buy_tokens[j];
        before = IERC20(token.contract).balanceOf(address(this));
    }
        
    opp.target_contract.call{value: opp.target_call_value}(opp.target_calldata);

    uint256[] after = new uint256[](opp.buy_tokens.length);
    for (uint j=0; j<opp.buy_tokens.length; j++) {
        let token = opp.buy_tokens[j];
        after = IERC20(token.target_contract).balanceOf(address(this));

        assert(after[j] == before[j] + token.amount);
    }
}
...
```

Note that the protocol contract (`opp.contract`) expects the caller to have already approved the necessary amount from the `sell_tokens` to the protocol. Also note that the custom contract will be expected to pay the specified bid in ETH while it is called.